1. 写一条查询性能最差的SQL [参考](https://blog.csdn.net/waterstar50/article/details/78062507)
2. 常见的分布式 锁有哪些
 * **分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”**
    >分布式锁实现的四个条件
    1. 互斥性，任意时刻只能有一个客户端持有锁
    2. 不会发生死锁<可重入锁>，即使只有一个客户端在持有锁期间崩溃而没有解锁，也能保证后续客户端加锁。
    3. 加锁和解锁必须要是同一个客户端
    4. 具有容错性
    > 基于数据库实现分布式锁：
    * 核心思想：在数据库中创建一个表，表中包含方法名的字段，并再方法名上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完后删除对应的行数据释放锁。
    * 实现方式有多种  数据库乐观锁
    > Redis 实现分布式锁
    * redis分布式锁既可以结合zk分布式锁高度安全和memcached并发效率好的特点
    * 核心思想：
    * [参考1](https://www.cnblogs.com/linjiqin/p/8003838.html)
    > ZooKeeper 方式实现分布式锁
    * 它是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，在同一个目录下只能有唯一的文件名。
    * 实现分数锁的步骤如下：
    ```
           1. 创建一个mylock目录
           2. 线程A想获取锁就在mylock创建一个临时顺序节点
           3. 获取mylock目录下所有子节点，然后获取比自己小的兄弟结点，如果不存在，则说明当前线程的顺序号最小，获取锁。
           4. 线程B获取所有节点，判断自己是不是最小节点，设置监听比自己小的结点。
           5. 线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小节点，如果是则获取锁。
           》 推荐使用Apache的Curator 它是Zookeeper的第三方库，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。
           优点：锁安全性高 zk可持久化
           缺点：性能开销比较高，因为需要动态生成，销毁节点来实现锁功能
    ```
    > memcached 实现分布式锁
    * 实现原理：memcached带有add函数，利用add函数的特性即可实现分布式锁。
        * add和set区别：若果多线程并发set，每个set都会成功，但最后存储的值以最后一个set为主。而add的话则相反，add会添加第一个到达的值，并返回true，后续的添加都会返回false。
    * 优点： 高效
    * 缺点： 它采用[LRU置换策略](https://baike.baidu.com/item/LRU/1269842?fr=aladdin)，<Least Recently Used>如果内存不够，可能会导致缓存中的锁信息丢失；无法持久化，一旦重启将导致信息丢失。
   
    
1. 分表 分区 分库的策略
* [参考](https://www.cnblogs.com/butterfly100/p/9034281.html)